<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: covenants/db.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: covenants/db.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/*!
 * namedb.js - name database for hsk
 * Copyright (c) 2017-2018, Christopher Jeffrey (MIT License).
 * https://github.com/handshake-org/hskd
 */

'use strict';

const assert = require('assert');
const bdb = require('bdb');
const Auction = require('./auction');
const rules = require('./rules');
const AuctionUndo = require('./undo');
const CoinView = require('../coins/coinview');
const HashList = require('../utils/hashlist');
const {states, AuctionState} = Auction;

/*
 * Database Layout:
 *   w -> name bucket
 *   a[name-hash] -> auction data
 *   u[height] -> undo ops
 *   p[name-hash] -> name tree pending list
 *   j[height] -> name tree journal
 *   r[height] -> previous root
 */

const layout = {
  w: bdb.key('w'),
  a: bdb.key('a', ['hash256']),
  u: bdb.key('u', ['uint32']),
  p: bdb.key('p', ['hash256']),
  j: bdb.key('j', ['uint32']),
  r: bdb.key('r', ['uint32'])
};

/**
 * NameDB
 */

class NameDB {
  constructor(chaindb) {
    this.chaindb = chaindb;
    this.db = chaindb.db;
    this.network = chaindb.network;
    this.logger = chaindb.logger;
    this.bucket = this.db.bucket(layout.w.build());
    this.treeInterval = this.network.names.treeInterval;
  }

  async getAuction(nameHash) {
    assert(Buffer.isBuffer(nameHash));

    const raw = await this.bucket.get(layout.a.build(nameHash));

    if (!raw)
      return null;

    const auction = Auction.fromRaw(raw);
    auction.nameHash = nameHash;
    return auction;
  }

  async getAuctionByName(name) {
    return this.getAuction(rules.hashName(name));
  }

  async getAuctionState(nameHash, height, hardened) {
    if (hardened == null)
      hardened = false;

    assert(Buffer.isBuffer(nameHash));
    assert((height >>> 0) === height);
    assert(typeof hardened === 'boolean');

    const network = this.network;
    const auction = await this.getAuction(nameHash);

    if (!auction) {
      const state = new AuctionState();
      state.reset(height);
      return state;
    }

    const state = auction.toState();

    if (hardened) {
      if (state.isWeak(height, network))
        state.reset(height);
    }

    if (state.isExpired(height, network))
      state.reset(height);

    return state;
  }

  /*
   * Connecting
   */

  async connect(batch, tree, view, height) {
    const b = this.bucket.wrap(batch);

    for (const auction of view.auctions.values()) {
      const {nameHash} = auction;

      this.writeAuction(b, auction);

      if (auction.dirty)
        b.put(layout.p.build(nameHash), null);
    }

    this.writeUndo(b, view, height);

    if ((height % this.treeInterval) === 0)
      await this.connectTree(b, tree, height);
  }

  writeUndo(b, view, height) {
    const undo = view.toAuctionUndo();

    if (undo.auctions.length === 0) {
      b.del(layout.u.build(height));
      return;
    }

    b.put(layout.u.build(height), undo.encode());
  }

  async updateTree(b, tree) {
    const updates = new HashList(32);

    const iter = this.bucket.iterator({
      gte: layout.p.min(),
      lte: layout.p.max()
    });

    await iter.each(async (key) => {
      assert(key.length === 33);
      assert(key[0] === 0x70);

      const nameHash = key.slice(1);
      const auction = await this.getAuction(nameHash);

      assert(!auction || !auction.isNull());

      if (auction)
        await tree.insert(nameHash, auction.toData());
      else
        await tree.remove(nameHash);

      updates.push(nameHash);

      b.del(key);
    });

    return updates;
  }

  async connectTree(b, tree, height) {
    assert((height % this.treeInterval) === 0);

    const prev = tree.rootHash();
    const updates = await this.updateTree(b, tree);

    if (updates.length === 0)
      return;

    b.put(layout.j.build(height), updates.encode());
    b.put(layout.r.build(height), prev);
  }

  /*
   * Disconnecting
   */

  async disconnect(batch, tree, view, height) {
    const b = this.bucket.wrap(batch);

    await this.disconnectState(b, view, height);

    if ((height % this.treeInterval) === 0)
      await this.disconnectTree(b, tree, height);
  }

  async disconnectState(b, view, height) {
    const raw = await this.bucket.get(layout.u.build(height));

    if (!raw)
      return;

    const undo = AuctionUndo.decode(raw);

    for (const [nameHash, delta] of undo.auctions) {
      const auction = await view.getAuction(this, nameHash);

      auction.applyState(delta);

      this.writeAuction(b, auction);
    }

    b.del(layout.u.build(height));
  }

  async unupdateTree(b, tree, height) {
    const iter = this.bucket.iterator({
      gte: layout.p.min(),
      lte: layout.p.max()
    });

    await iter.each(key => b.del(key));

    const prev = await this.bucket.get(layout.r.build(height));

    if (!prev)
      return;

    assert(prev.length === 32);

    await tree.inject(prev);

    b.del(layout.r.build(height));
  }

  async disconnectTree(b, tree, height) {
    assert((height % this.treeInterval) === 0);

    await this.unupdateTree(b, tree, height);

    const raw = await this.bucket.get(layout.j.build(height));

    if (!raw)
      return;

    const updates = HashList.decode(raw, 32);

    for (const nameHash of updates)
      b.put(layout.p.build(nameHash), null);

    b.del(layout.j.build(height));
  }

  writeAuction(b, auction) {
    const {nameHash} = auction;

    if (auction.isNull())
      b.del(layout.a.build(nameHash));
    else
      b.put(layout.a.build(nameHash), auction.toRaw());
  }

  async verifyRenewal(blockHash, height) {
    assert(Buffer.isBuffer(blockHash));
    assert((height >>> 0) === height);

    // Cannot renew yet.
    if (height &lt; this.network.names.renewalMaturity)
      return true;

    // We require renewals to commit to a block
    // within the past 6 months, to prove that
    // the user still owns the key. This prevents
    // people from presigning thousands of years
    // worth of renewals. The block must be at
    // least 400 blocks back to prevent the
    // possibility of a reorg invalidating the
    // covenant.

    const hash = blockHash.toString('hex');
    const entry = await this.chaindb.getEntry(hash);

    if (!entry)
      return false;

    // Must be the current chain.
    if (!await this.chaindb.isMainChain(entry))
      return false;

    // Make sure it's a mature block (unlikely to be reorgd).
    if (entry.height > height - this.network.names.renewalMaturity)
      return false;

    // Block committed to must be
    // no older than a 6 months.
    if (entry.height &lt; height - this.network.names.renewalPeriod)
      return false;

    return true;
  }

  async validate(tx, height, hardened) {
    const view = new CoinView();
    return this.process(tx, view, height, hardened);
  }

  async process(tx, view, height, hardened) {
    const [valid, reason] = await this.check(tx, view, height, hardened);

    if (!valid) {
      this.logger.debug(
        'Invalid covenant for %s (%d): %s.',
        tx.hash('hex'),
        height,
        reason);
    }

    return valid;
  }

  async check(tx, view, height, hardened) {
    assert(tx);
    assert(view instanceof CoinView);
    assert((height >>> 0) === height);
    assert(typeof hardened === 'boolean');

    const {types} = rules;
    const network = this.network;

    for (let i = 0; i &lt; tx.outputs.length; i++) {
      const output = tx.outputs[i];
      const {covenant} = output;

      if (covenant.type &lt; types.CLAIM
          || covenant.type > types.REVOKE) {
        continue;
      }

      const nameHash = covenant.items[0];
      const auction = await view.getAuction(this, nameHash);

      if (auction.isNull()) {
        switch (covenant.type) {
          case types.CLAIM:
          case types.OPEN:
            break;
          default:
            throw new Error('Database inconsistency.');
        }
        const name = covenant.items[1];
        auction.setAuction(name, height);
      }

      // Once the soft-fork is activated,
      // any name that used a weak algorithm
      // must be re-claimed with a proper key.
      let existed = false;
      if (hardened) {
        if (auction.isWeak(height, network)) {
          auction.reset(height);
          existed = true;
        }
      }

      // Check for name expiration/revocation.
      let expired = false;
      if (auction.isExpired(height, network)) {
        auction.reset(height);
        expired = true;
      }

      // Calculate the current state.
      const state = auction.state(height, network);

      // none/redeem -> claim
      if (covenant.type === types.CLAIM) {
        const name = covenant.items[1];
        const flags = covenant.items[2][0];
        const weak = (flags &amp; 1) === 1;
        const forked = (flags &amp; 2) === 2;

        if (state !== states.OPENING)
          return [false, 'bad-claim-state'];

        // Can only claim reserved names.
        if (!rules.isReserved(nameHash, height, network))
          return [false, 'bad-claim-notreserved'];

        // Once a reserved name expires or is
        // revoked, it is no longer claimable.
        if (expired)
          return [false, 'bad-claim-state'];

        // Participant must commit to the fork.
        if (forked !== existed)
          return [false, 'bad-claim-flags'];

        // Once the fork is active, we reject
        // any weak algorithms (i.e. RSA-1024).
        if (hardened &amp;&amp; weak)
          return [false, 'bad-claim-algorithm'];

        auction.setClaimed(true);
        auction.setValue(0);
        auction.setOwner(tx.outpoint(i));
        auction.setHighest(0);
        auction.setWeak(weak);
        auction.dirty = true;

        continue;
      }

      assert(!tx.isCoinbase());

      // none/redeem/open -> open
      if (covenant.type === types.OPEN) {
        const name = covenant.items[1];

        if (state !== states.OPENING)
          return [false, 'bad-open-state'];

        // Only one open transaction can ever exist.
        if (auction.dirty || auction.height !== height)
          return [false, 'bad-open-multiple'];

        // Cannot bid on a reserved name.
        if (rules.isReserved(nameHash, height, network))
          return [false, 'bad-open-reserved'];

        // On mainnet, names are released on a
        // weekly basis for the first year.
        if (!rules.verifyRollout(nameHash, height, network))
          return [false, 'bad-open-rollout'];

        auction.dirty = true;

        continue;
      }

      // none/redeem/open -> bid
      if (covenant.type === types.BID) {
        const start = covenant.items[2].readUInt32LE(0);

        if (state !== states.BIDDING)
          return [false, 'bad-bid-state'];

        if (start !== auction.height)
          return [false, 'bad-bid-height'];

        continue;
      }

      assert(i &lt; tx.inputs.length);

      const {prevout} = tx.inputs[i];
      const local = auction.isLocal(view, prevout);

      switch (covenant.type) {
        // bid -> reveal
        case types.REVEAL: {
          if (!local)
            return [false, 'bad-reveal-nonlocal'];

          // Early reveals? No.
          if (state !== states.REVEAL)
            return [false, 'bad-reveal-state'];

          if (output.value > auction.highest) {
            auction.setValue(auction.highest);
            auction.setOwner(tx.outpoint(i));
            auction.setHighest(output.value);
          } else if (output.value > auction.value) {
            auction.setValue(output.value);
          }

          break;
        }

        // reveal -> redeem
        case types.REDEEM: {
          if (!local)
            return [false, 'bad-redeem-nonlocal'];

          // Allow participants to get their
          // money out, even in a revoked state.
          if (state &lt; states.CLOSED)
            return [false, 'bad-redeem-state'];

          // Must be the loser in order
          // to redeem the money now.
          if (prevout.equals(auction.owner))
            return [false, 'bad-redeem-owner'];

          break;
        }

        // claim/reveal -> register
        case types.REGISTER: {
          if (!local)
            return [false, 'bad-register-nonlocal'];

          if (state !== states.CLOSED)
            return [false, 'bad-register-state'];

          const data = covenant.items[1];
          const hash = covenant.items[2];

          // Verify block hash for renewal.
          if (!await this.verifyRenewal(hash, height))
            return [false, 'bad-register-renewal'];

          // Must be the winner in
          // order to redeem the name.
          if (!prevout.equals(auction.owner))
            return [false, 'bad-register-owner'];

          // If we didn't have a second
          // bidder, use our own bid.
          if (auction.value === -1) {
            assert(auction.highest !== -1);
            auction.setValue(auction.highest);
          }

          // Must match the second highest bid.
          if (output.value !== auction.value)
            return [false, 'bad-register-value'];

          auction.setOwner(tx.outpoint(i));

          if (data.length > 0)
            auction.setData(data);

          auction.setRenewal(height);

          break;
        }

        // update/register/finalize -> update
        case types.UPDATE: {
          if (!local)
            return [false, 'bad-update-nonlocal'];

          if (state !== states.CLOSED)
            return [false, 'bad-update-state'];

          const data = covenant.items[1];

          auction.setOwner(tx.outpoint(i));
          auction.setTransfer(-1);

          if (data.length > 0)
            auction.setData(data);

          // Verify renewal if there is one.
          if (covenant.items.length === 3) {
            const hash = covenant.items[2];

            if (!await this.verifyRenewal(hash, height))
              return [false, 'bad-update-renewal'];

            auction.setRenewal(height);
          }

          break;
        }

        // update/register/finalize -> transfer
        case types.TRANSFER: {
          if (!local)
            return [false, 'bad-transfer-nonlocal'];

          if (state !== states.CLOSED)
            return [false, 'bad-transfer-state'];

          if (auction.isWeak(height, network))
            return [false, 'bad-transfer-state'];

          auction.setOwner(tx.outpoint(i));

          assert(auction.transfer === -1);
          auction.setTransfer(height);

          // Verify renewal if there is one.
          if (covenant.items.length === 3) {
            const hash = covenant.items[2];

            if (!await this.verifyRenewal(hash, height))
              return [false, 'bad-transfer-renewal'];

            auction.setRenewal(height);
          }

          break;
        }

        // transfer -> finalize
        case types.FINALIZE: {
          if (!local)
            return [false, 'bad-finalize-nonlocal'];

          if (state !== states.CLOSED)
            return [false, 'bad-finalize-state'];

          assert(auction.transfer !== -1);

          if (height &lt; auction.transfer + network.names.transferLockup)
            return [false, 'bad-finalize-maturity'];

          const start = covenant.items[2].readUInt32LE(0);
          const weak = (covenant.items[3][0] &amp; 1) === 1;
          const claimed = (covenant.items[3][0] &amp; 4) === 4;
          const hash = covenant.items[4];

          if (start !== auction.height
              || weak !== auction.weak
              || claimed !== auction.claimed) {
            return [false, 'bad-finalize-statetransfer'];
          }

          if (!await this.verifyRenewal(hash, height))
            return [false, 'bad-finalize-renewal'];

          auction.setOwner(tx.outpoint(i));
          auction.setTransfer(-1);
          auction.setRenewal(height);

          break;
        }

        // register/update/transfer/finalize -> revoke
        case types.REVOKE: {
          if (!local)
            return [false, 'bad-revoke-nonlocal'];

          if (state !== states.CLOSED)
            return [false, 'bad-revoke-state'];

          if (auction.isWeak(height, network))
            return [false, 'bad-revoke-state'];

          assert(auction.revoked === -1);
          auction.setRevoked(height);
          auction.setData(null);

          break;
        }
      }
    }

    return [true, 'valid'];
  }
}

/*
 * Expose
 */

module.exports = NameDB;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-blockchain.html">blockchain</a></li><li><a href="module-blockchain_common.html">blockchain/common</a></li><li><a href="module-btc.html">btc</a></li><li><a href="module-coins.html">coins</a></li><li><a href="module-hd.html">hd</a></li><li><a href="module-hsk.html">hsk</a></li><li><a href="module-mempool.html">mempool</a></li><li><a href="module-mining.html">mining</a></li><li><a href="module-mining_common.html">mining/common</a></li><li><a href="module-net.html">net</a></li><li><a href="module-net_bip152.html">net/bip152</a></li><li><a href="module-net_common.html">net/common</a></li><li><a href="module-net_packets.html">net/packets</a></li><li><a href="module-node.html">node</a></li><li><a href="module-primitives.html">primitives</a></li><li><a href="module-protocol.html">protocol</a></li><li><a href="module-protocol_consensus.html">protocol/consensus</a></li><li><a href="module-protocol_errors.html">protocol/errors</a></li><li><a href="module-protocol_networks.html">protocol/networks</a></li><li><a href="module-protocol_policy.html">protocol/policy</a></li><li><a href="module-script.html">script</a></li><li><a href="module-script_common.html">script/common</a></li><li><a href="module-utils.html">utils</a></li><li><a href="module-utils_util.html">utils/util</a></li><li><a href="module-wallet.html">wallet</a></li><li><a href="module-wallet_common.html">wallet/common</a></li><li><a href="module-wallet_plugin.html">wallet/plugin</a></li><li><a href="module-wallet_records.html">wallet/records</a></li><li><a href="module-workers.html">workers</a></li><li><a href="module-workers_jobs.html">workers/jobs</a></li><li><a href="module-workers_packets.html">workers/packets</a></li></ul><h3>Classes</h3><ul><li><a href="Addr.html">Addr</a></li><li><a href="Auction.html">Auction</a></li><li><a href="AuctionDelta.html">AuctionDelta</a></li><li><a href="AuctionState.html">AuctionState</a></li><li><a href="BidReveal.html">BidReveal</a></li><li><a href="BlindBid.html">BlindBid</a></li><li><a href="BlindValue.html">BlindValue</a></li><li><a href="BlockProof.html">BlockProof</a></li><li><a href="Brontide.html">Brontide</a></li><li><a href="BrontideStream.html">BrontideStream</a></li><li><a href="CacheUpdate.html">CacheUpdate</a></li><li><a href="ChainFlags.html">ChainFlags</a></li><li><a href="ChainState.html">ChainState</a></li><li><a href="CipherState.html">CipherState</a></li><li><a href="Claim.html">Claim</a></li><li><a href="Compressor.html">Compressor</a></li><li><a href="Decompressor.html">Decompressor</a></li><li><a href="DetailsMember.html">DetailsMember</a></li><li><a href="DS.html">DS</a></li><li><a href="Extra.html">Extra</a></li><li><a href="HandshakeState.html">HandshakeState</a></li><li><a href="HashList.html">HashList</a></li><li><a href="ICANN.html">ICANN</a></li><li><a href="Location.html">Location</a></li><li><a href="Magnet.html">Magnet</a></li><li><a href="MerkleTree.html">MerkleTree</a></li><li><a href="module-blockchain.Chain.html">Chain</a></li><li><a href="module-blockchain.ChainDB.html">ChainDB</a></li><li><a href="module-blockchain.ChainEntry.html">ChainEntry</a></li><li><a href="module-blockchain.ChainOptions.html">ChainOptions</a></li><li><a href="module-blockchain.DeploymentState.html">DeploymentState</a></li><li><a href="module-btc.URI.html">URI</a></li><li><a href="module-coins.CoinEntry.html">CoinEntry</a></li><li><a href="module-coins.Coins.html">Coins</a></li><li><a href="module-coins.CoinView.html">CoinView</a></li><li><a href="module-coins.UndoCoins.html">UndoCoins</a></li><li><a href="module-currency.Amount.html">Amount</a></li><li><a href="module-hd.Mnemonic.html">Mnemonic</a></li><li><a href="module-hd.PrivateKey.html">PrivateKey</a></li><li><a href="module-hd.PublicKey.html">PublicKey</a></li><li><a href="module-http.HTTPOptions.html">HTTPOptions</a></li><li><a href="module-http.RPC.html">RPC</a></li><li><a href="module-http.Server.html">Server</a></li><li><a href="module-mempool.ClaimEntry.html">ClaimEntry</a></li><li><a href="module-mempool.ConfirmStats.html">ConfirmStats</a></li><li><a href="module-mempool.Mempool.html">Mempool</a></li><li><a href="module-mempool.MempoolEntry.html">MempoolEntry</a></li><li><a href="module-mempool.MempoolOptions.html">MempoolOptions</a></li><li><a href="module-mempool.PolicyEstimator.html">PolicyEstimator</a></li><li><a href="module-mining.BlockClaim.html">BlockClaim</a></li><li><a href="module-mining.BlockEntry.html">BlockEntry</a></li><li><a href="module-mining.BlockTemplate.html">BlockTemplate</a></li><li><a href="module-mining.CPUMiner.html">CPUMiner</a></li><li><a href="module-mining.Miner.html">Miner</a></li><li><a href="module-mining.MinerOptions.html">MinerOptions</a></li><li><a href="module-net.BroadcastItem.html">BroadcastItem</a></li><li><a href="module-net.Framer.html">Framer</a></li><li><a href="module-net.HostEntry.html">HostEntry</a></li><li><a href="module-net.HostList.html">HostList</a></li><li><a href="module-net.HostListOptions.html">HostListOptions</a></li><li><a href="module-net.LocalAddress.html">LocalAddress</a></li><li><a href="module-net.NetAddress.html">NetAddress</a></li><li><a href="module-net.Parser.html">Parser</a></li><li><a href="module-net.Peer.html">Peer</a></li><li><a href="module-net.PeerList.html">PeerList</a></li><li><a href="module-net.PeerOptions.html">PeerOptions</a></li><li><a href="module-net.Pool.html">Pool</a></li><li><a href="module-net.PoolOptions.html">PoolOptions</a></li><li><a href="module-net_bip152-CompactBlock.html">CompactBlock</a></li><li><a href="module-net_bip152-TXRequest.html">TXRequest</a></li><li><a href="module-net_bip152-TXResponse.html">TXResponse</a></li><li><a href="module-net_packets-AddrPacket.html">AddrPacket</a></li><li><a href="module-net_packets-BlockPacket.html">BlockPacket</a></li><li><a href="module-net_packets-BlockTxnPacket.html">BlockTxnPacket</a></li><li><a href="module-net_packets-ClaimPacket.html">ClaimPacket</a></li><li><a href="module-net_packets-CmpctBlockPacket.html">CmpctBlockPacket</a></li><li><a href="module-net_packets-FeeFilterPacket.html">FeeFilterPacket</a></li><li><a href="module-net_packets-FilterAddPacket.html">FilterAddPacket</a></li><li><a href="module-net_packets-FilterClearPacket.html">FilterClearPacket</a></li><li><a href="module-net_packets-FilterLoadPacket.html">FilterLoadPacket</a></li><li><a href="module-net_packets-GetAddrPacket.html">GetAddrPacket</a></li><li><a href="module-net_packets-GetBlocksPacket.html">GetBlocksPacket</a></li><li><a href="module-net_packets-GetBlockTxnPacket.html">GetBlockTxnPacket</a></li><li><a href="module-net_packets-GetDataPacket.html">GetDataPacket</a></li><li><a href="module-net_packets-GetHeadersPacket.html">GetHeadersPacket</a></li><li><a href="module-net_packets-GetProofPacket.html">GetProofPacket</a></li><li><a href="module-net_packets-HeadersPacket.html">HeadersPacket</a></li><li><a href="module-net_packets-InvPacket.html">InvPacket</a></li><li><a href="module-net_packets-MempoolPacket.html">MempoolPacket</a></li><li><a href="module-net_packets-MerkleBlockPacket.html">MerkleBlockPacket</a></li><li><a href="module-net_packets-NotFoundPacket.html">NotFoundPacket</a></li><li><a href="module-net_packets-Packet.html">Packet</a></li><li><a href="module-net_packets-PingPacket.html">PingPacket</a></li><li><a href="module-net_packets-PongPacket.html">PongPacket</a></li><li><a href="module-net_packets-ProofPacket.html">ProofPacket</a></li><li><a href="module-net_packets-RejectPacket.html">RejectPacket</a></li><li><a href="module-net_packets-SendCmpctPacket.html">SendCmpctPacket</a></li><li><a href="module-net_packets-SendHeadersPacket.html">SendHeadersPacket</a></li><li><a href="module-net_packets-TXPacket.html">TXPacket</a></li><li><a href="module-net_packets-UnknownPacket.html">UnknownPacket</a></li><li><a href="module-net_packets-VerackPacket.html">VerackPacket</a></li><li><a href="module-net_packets-VersionPacket.html">VersionPacket</a></li><li><a href="module-node.FullNode.html">FullNode</a></li><li><a href="module-node.Node.html">Node</a></li><li><a href="module-node.NodeClient.html">NodeClient</a></li><li><a href="module-node.NullClient.html">NullClient</a></li><li><a href="module-node.SPVNode.html">SPVNode</a></li><li><a href="module-primitives.AbstractBlock.html">AbstractBlock</a></li><li><a href="module-primitives.Address.html">Address</a></li><li><a href="module-primitives.Block.html">Block</a></li><li><a href="module-primitives.Coin.html">Coin</a></li><li><a href="module-primitives.CoinSelector.html">CoinSelector</a></li><li><a href="module-primitives.Covenant.html">Covenant</a></li><li><a href="module-primitives.Headers.html">Headers</a></li><li><a href="module-primitives.Input.html">Input</a></li><li><a href="module-primitives.InvItem.html">InvItem</a></li><li><a href="module-primitives.KeyRing.html">KeyRing</a></li><li><a href="module-primitives.MemBlock.html">MemBlock</a></li><li><a href="module-primitives.MerkleBlock.html">MerkleBlock</a></li><li><a href="module-primitives.MTX.html">MTX</a></li><li><a href="module-primitives.Outpoint.html">Outpoint</a></li><li><a href="module-primitives.Output.html">Output</a></li><li><a href="module-primitives.TX.html">TX</a></li><li><a href="module-primitives.TXMeta.html">TXMeta</a></li><li><a href="module-protocol.Network.html">Network</a></li><li><a href="module-protocol.TimeData.html">TimeData</a></li><li><a href="module-protocol_errors-VerifyError.html">VerifyError</a></li><li><a href="module-script.Opcode.html">Opcode</a></li><li><a href="module-script.Script.html">Script</a></li><li><a href="module-script.ScriptError.html">ScriptError</a></li><li><a href="module-script.ScriptNum.html">ScriptNum</a></li><li><a href="module-script.SigCache.html">SigCache</a></li><li><a href="module-script.Stack.html">Stack</a></li><li><a href="module-script.Witness.html">Witness</a></li><li><a href="module-wallet.Account.html">Account</a></li><li><a href="module-wallet.Balance.html">Balance</a></li><li><a href="module-wallet.BlockRecord.html">BlockRecord</a></li><li><a href="module-wallet.Credit.html">Credit</a></li><li><a href="module-wallet.Details.html">Details</a></li><li><a href="module-wallet.HTTP.html">HTTP</a></li><li><a href="module-wallet.MasterKey.html">MasterKey</a></li><li><a href="module-wallet.Path.html">Path</a></li><li><a href="module-wallet.RPC.html">RPC</a></li><li><a href="module-wallet.TXDB.html">TXDB</a></li><li><a href="module-wallet.Wallet.html">Wallet</a></li><li><a href="module-wallet.WalletDB.html">WalletDB</a></li><li><a href="module-wallet.WalletKey.html">WalletKey</a></li><li><a href="module-wallet.WalletOptions.html">WalletOptions</a></li><li><a href="module-wallet_plugin-Plugin.html">Plugin</a></li><li><a href="module-wallet_records-BlockMeta.html">BlockMeta</a></li><li><a href="module-wallet_records-ChainState.html">ChainState</a></li><li><a href="module-wallet_records-MapRecord.html">MapRecord</a></li><li><a href="module-wallet_records-TXRecord.html">TXRecord</a></li><li><a href="module-workers.Framer.html">Framer</a></li><li><a href="module-workers.Master.html">Master</a></li><li><a href="module-workers.Parent.html">Parent</a></li><li><a href="module-workers.Parser.html">Parser</a></li><li><a href="module-workers.Worker.html">Worker</a></li><li><a href="module-workers.WorkerPool.html">WorkerPool</a></li><li><a href="module-workers_packets-CheckInputPacket.html">CheckInputPacket</a></li><li><a href="module-workers_packets-CheckInputResultPacket.html">CheckInputResultPacket</a></li><li><a href="module-workers_packets-CheckPacket.html">CheckPacket</a></li><li><a href="module-workers_packets-CheckResultPacket.html">CheckResultPacket</a></li><li><a href="module-workers_packets-ECSignPacket.html">ECSignPacket</a></li><li><a href="module-workers_packets-ECSignResultPacket.html">ECSignResultPacket</a></li><li><a href="module-workers_packets-ECVerifyPacket.html">ECVerifyPacket</a></li><li><a href="module-workers_packets-ECVerifyResultPacket.html">ECVerifyResultPacket</a></li><li><a href="module-workers_packets-EnvPacket.html">EnvPacket</a></li><li><a href="module-workers_packets-ErrorPacket.html">ErrorPacket</a></li><li><a href="module-workers_packets-ErrorResultPacket.html">ErrorResultPacket</a></li><li><a href="module-workers_packets-EventPacket.html">EventPacket</a></li><li><a href="module-workers_packets-LogPacket.html">LogPacket</a></li><li><a href="module-workers_packets-MinePacket.html">MinePacket</a></li><li><a href="module-workers_packets-MineResultPacket.html">MineResultPacket</a></li><li><a href="module-workers_packets-Packet.html">Packet</a></li><li><a href="module-workers_packets-ScryptPacket.html">ScryptPacket</a></li><li><a href="module-workers_packets-ScryptResultPacket.html">ScryptResultPacket</a></li><li><a href="module-workers_packets-SignInputPacket.html">SignInputPacket</a></li><li><a href="module-workers_packets-SignInputResultPacket.html">SignInputResultPacket</a></li><li><a href="module-workers_packets-SignPacket.html">SignPacket</a></li><li><a href="module-workers_packets-SignResultPacket.html">SignResultPacket</a></li><li><a href="NameDB.html">NameDB</a></li><li><a href="Ownership.html">Ownership</a></li><li><a href="PGP.html">PGP</a></li><li><a href="Proof.html">Proof</a></li><li><a href="RecursiveServer.html">RecursiveServer</a></li><li><a href="Reserved.html">Reserved</a></li><li><a href="Resource.html">Resource</a></li><li><a href="RootCache.html">RootCache</a></li><li><a href="RootServer.html">RootServer</a></li><li><a href="Service.html">Service</a></li><li><a href="SMIME.html">SMIME</a></li><li><a href="SSH.html">SSH</a></li><li><a href="StateCache.html">StateCache</a></li><li><a href="SymmetricState.html">SymmetricState</a></li><li><a href="Target.html">Target</a></li><li><a href="TLS.html">TLS</a></li><li><a href="WalletNode.html">WalletNode</a></li></ul><h3>Global</h3><ul><li><a href="global.html#bindExit">bindExit</a></li><li><a href="global.html#checkOutput">checkOutput</a></li><li><a href="global.html#checksig">checksig</a></li><li><a href="global.html#decode">decode</a></li><li><a href="global.html#encode">encode</a></li><li><a href="global.html#fromFloat">fromFloat</a></li><li><a href="global.html#insert">insert</a></li><li><a href="global.html#listenExit">listenExit</a></li><li><a href="global.html#remove">remove</a></li><li><a href="global.html#search">search</a></li><li><a href="global.html#toFloat">toFloat</a></li><li><a href="global.html#types">types</a></li><li><a href="global.html#validateKey">validateKey</a></li><li><a href="global.html#validateSignature">validateSignature</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Thu Jul 19 2018 21:52:41 GMT-0700 (PDT)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
